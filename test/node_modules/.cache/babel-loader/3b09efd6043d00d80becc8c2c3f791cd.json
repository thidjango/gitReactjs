{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _SCALE_FUNCTIONS;\n\nexports._getSmallestDistanceIndex = _getSmallestDistanceIndex;\nexports.getScaleFnFromScaleObject = getScaleFnFromScaleObject;\nexports.getDomainByAccessor = getDomainByAccessor;\nexports._getScaleDistanceAndAdjustedDomain = _getScaleDistanceAndAdjustedDomain;\nexports._adjustCategoricalScale = _adjustCategoricalScale;\nexports.getScaleObjectFromProps = getScaleObjectFromProps;\nexports.getAttributeScale = getAttributeScale;\nexports.getAttributeFunctor = getAttributeFunctor;\nexports.getAttr0Functor = getAttr0Functor;\nexports.getAttributeValue = getAttributeValue;\nexports.getScalePropTypesByAttribute = getScalePropTypesByAttribute;\nexports.extractScalePropsFromProps = extractScalePropsFromProps;\nexports.getMissingScaleProps = getMissingScaleProps;\nexports.literalScale = literalScale;\nexports.getFontColorFromBackground = getFontColorFromBackground;\nexports.getXYPlotValues = getXYPlotValues;\nexports.getOptionalScaleProps = getOptionalScaleProps;\n\nvar _d3Scale = require('d3-scale');\n\nvar _d3Array = require('d3-array');\n\nvar _d3Collection = require('d3-collection');\n\nvar _d3Color = require('d3-color');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactUtils = require('./react-utils');\n\nvar _dataUtils = require('./data-utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\n\n\nvar LINEAR_SCALE_TYPE = 'linear';\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\n\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n/**\n * Category scale.\n * @type {string}\n * @const\n */\n\nvar CATEGORY_SCALE_TYPE = 'category';\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\n\nvar LITERAL_SCALE_TYPE = 'literal';\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\n\nvar LOG_SCALE_TYPE = 'log';\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_SCALE_TYPE = 'time';\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\n\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, _d3Scale.scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, _d3Scale.scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, _d3Scale.scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, _d3Scale.scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, _d3Scale.scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, _d3Scale.scaleUtc), _SCALE_FUNCTIONS);\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\n\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\n\n\nfunction _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n\n      currentValue = nextValue;\n    }\n  }\n\n  return result;\n}\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\n\n\nfunction getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n\n  return scale;\n}\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\n\n\nfunction getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0; // Collect both attr and available attr0 values from the array of data.\n\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  } // Create proper domain depending on the type of the scale.\n\n\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = (0, _d3Array.extent)(values);\n  } else {\n    domain = (0, _d3Collection.set)(values).values();\n  }\n\n  return domain;\n}\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\n\n\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n\n  if (typeof value === 'undefined') {\n    return null;\n  }\n\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\n\n\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\n\n\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain']; // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  } // Pick up the domain from the properties and create a new one if it's not\n  // available.\n\n\n  if (typeof baseValue !== 'undefined') {\n    domain = (0, _dataUtils.addValueToArray)(domain, baseValue);\n  } // Make sure that the minimum necessary properties exist.\n\n\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n\n  return 0;\n}\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\n\n\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\n\n\nfunction _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n  var uniqueValues = (0, _dataUtils.getUniquePropertyValues)(data, accessor); // Fix time scale if a data has only one value.\n\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values); // Fix log scale if it's too small.\n\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\n\n\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat; // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2; // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance; // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nfunction _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\n\n\nfunction getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n\n  if (!scaleObject) {\n    return null;\n  } // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n\n\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type; // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n\n  return _adjustContinuousScale(props, scaleObject);\n}\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\n\n\nfunction getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\n\n\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\n\n\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\n\n\nfunction getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n\n  return null;\n}\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\n\n\nfunction getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n\n  return null;\n}\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\n\n\nfunction getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      (0, _reactUtils.warning)('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n\n  return null;\n}\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\n\n\nfunction getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', _propTypes2.default.any), _defineProperty(_ref2, attr + 'Domain', _propTypes2.default.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), _propTypes2.default.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', _propTypes2.default.func), _defineProperty(_ref2, attr + 'Range', _propTypes2.default.array), _defineProperty(_ref2, attr + 'Type', _propTypes2.default.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', _propTypes2.default.number), _defineProperty(_ref2, attr + 'BaseValue', _propTypes2.default.any), _ref2;\n}\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\n\nfunction extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0; // Ex: _data\n\n      var isUnderscoreSet = key.indexOf('_' + a) === 0; // EX: getX\n\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n\n    if (!attr) {\n      return;\n    }\n\n    result[key] = props[key];\n  });\n  return result;\n}\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\n\nfunction getMissingScaleProps(props, data, attributes) {\n  var result = {}; // Make sure that the domain is set pad it if specified\n\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\n\n\nfunction literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\n\nfunction getFontColorFromBackground(background) {\n  if (background) {\n    return (0, _d3Color.hsl)(background).l > 0.57 ? '#222' : '#fff';\n  }\n\n  return null;\n}\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\n\nfunction getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n\n      return prev;\n    }, {});\n  });\n}\n\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\n\nfunction getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n\n    if (propIsNotOptional) {\n      return acc;\n    }\n\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\n\nexports.default = {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};","map":{"version":3,"sources":["D:/reactjs/test/node_modules/react-vis/dist/utils/scales-utils.js"],"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","err","Array","isArray","TypeError","_SCALE_FUNCTIONS","_getSmallestDistanceIndex","getScaleFnFromScaleObject","getDomainByAccessor","_getScaleDistanceAndAdjustedDomain","_adjustCategoricalScale","getScaleObjectFromProps","getAttributeScale","getAttributeFunctor","getAttr0Functor","getAttributeValue","getScalePropTypesByAttribute","extractScalePropsFromProps","getMissingScaleProps","literalScale","getFontColorFromBackground","getXYPlotValues","getOptionalScaleProps","_d3Scale","require","_d3Array","_d3Collection","_d3Color","_propTypes","_propTypes2","_interopRequireDefault","_reactUtils","_dataUtils","obj","__esModule","default","_toConsumableArray","arr2","from","_defineProperty","enumerable","configurable","writable","LINEAR_SCALE_TYPE","ORDINAL_SCALE_TYPE","CATEGORY_SCALE_TYPE","LITERAL_SCALE_TYPE","LOG_SCALE_TYPE","TIME_SCALE_TYPE","TIME_UTC_SCALE_TYPE","SCALE_FUNCTIONS","scaleLinear","scalePoint","scaleOrdinal","scaleLog","scaleTime","scaleUtc","XYPLOT_ATTR","toTitleCase","str","toUpperCase","slice","values","scaleObject","scaleFn","result","nextValue","currentValue","distance","Infinity","nextDistance","Math","abs","addInvertFunctionToOrdinalScaleObject","scale","invert","_scale$range","range","_scale$range2","lower","upper","start","min","stop","max","padding","step","domain","index","floor","type","modDomain","allData","accessor","accessor0","reduce","data","d","value0","_isDefined","extent","set","_createScaleObjectForValue","attr","baseValue","isValue","_createScaleObjectForFunction","_ref","_collectScaleObjectFromProps","props","fallbackValue","_props$","_props$2","noFallBack","_props$3","_props$4","addValueToArray","_computeLeftDomainAdjustment","_computeRightDomainAdjustment","_computeScaleDistance","bestDistIndex","_normalizeValues","attr0","concat","uniqueValues","getUniquePropertyValues","adjustedDomain","adjustedScaleFn","domain0","domainN","_isScaleAdjustmentPossible","_props$_adjustBy","_adjustBy","adjustBy","_props$_adjustWhat","_adjustWhat","adjustWhat","indexOf","_adjustContinuousScale","allSeriesData","_allData","_props$_adjustWhat2","domainLength","scaleDomain0","scaleDomainN","scaleDistance","forEach","_getScaleDistanceAndA","_getAttrValue","_padDomain","isNaN","parseFloat","_domain","domainPadding","_scaleObject$baseValu","warning","_ref2","any","array","func","oneOf","keys","number","attributes","find","a","isPlainSet","isUnderscoreSet","usesGet","defaultValue","response","unknown","copy","background","hsl","l","children","XYPlotScales","prev","map","child","scaleInput","OPTIONAL_SCALE_PROPS","OPTIONAL_SCALE_PROPS_REGS","RegExp","acc","prop","propIsNotOptional","every","reg","match"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _SCALE_FUNCTIONS;\n\nexports._getSmallestDistanceIndex = _getSmallestDistanceIndex;\nexports.getScaleFnFromScaleObject = getScaleFnFromScaleObject;\nexports.getDomainByAccessor = getDomainByAccessor;\nexports._getScaleDistanceAndAdjustedDomain = _getScaleDistanceAndAdjustedDomain;\nexports._adjustCategoricalScale = _adjustCategoricalScale;\nexports.getScaleObjectFromProps = getScaleObjectFromProps;\nexports.getAttributeScale = getAttributeScale;\nexports.getAttributeFunctor = getAttributeFunctor;\nexports.getAttr0Functor = getAttr0Functor;\nexports.getAttributeValue = getAttributeValue;\nexports.getScalePropTypesByAttribute = getScalePropTypesByAttribute;\nexports.extractScalePropsFromProps = extractScalePropsFromProps;\nexports.getMissingScaleProps = getMissingScaleProps;\nexports.literalScale = literalScale;\nexports.getFontColorFromBackground = getFontColorFromBackground;\nexports.getXYPlotValues = getXYPlotValues;\nexports.getOptionalScaleProps = getOptionalScaleProps;\n\nvar _d3Scale = require('d3-scale');\n\nvar _d3Array = require('d3-array');\n\nvar _d3Collection = require('d3-collection');\n\nvar _d3Color = require('d3-color');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactUtils = require('./react-utils');\n\nvar _dataUtils = require('./data-utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\nvar LINEAR_SCALE_TYPE = 'linear';\n\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n\n/**\n * Category scale.\n * @type {string}\n * @const\n */\nvar CATEGORY_SCALE_TYPE = 'category';\n\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\nvar LITERAL_SCALE_TYPE = 'literal';\n\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\nvar LOG_SCALE_TYPE = 'log';\n\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\nvar TIME_SCALE_TYPE = 'time';\n\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, _d3Scale.scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, _d3Scale.scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, _d3Scale.scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, _d3Scale.scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, _d3Scale.scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, _d3Scale.scaleUtc), _SCALE_FUNCTIONS);\n\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\nfunction _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n      currentValue = nextValue;\n    }\n  }\n  return result;\n}\n\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\nfunction getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n  return scale;\n}\n\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\nfunction getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0;\n\n  // Collect both attr and available attr0 values from the array of data.\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  }\n\n  // Create proper domain depending on the type of the scale.\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = (0, _d3Array.extent)(values);\n  } else {\n    domain = (0, _d3Collection.set)(values).values();\n  }\n  return domain;\n}\n\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n  if (typeof value === 'undefined') {\n    return null;\n  }\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain'];\n  // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  }\n  // Pick up the domain from the properties and create a new one if it's not\n  // available.\n  if (typeof baseValue !== 'undefined') {\n    domain = (0, _dataUtils.addValueToArray)(domain, baseValue);\n  }\n\n  // Make sure that the minimum necessary properties exist.\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n  return 0;\n}\n\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\nfunction _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n\n\n  var uniqueValues = (0, _dataUtils.getUniquePropertyValues)(data, accessor);\n\n  // Fix time scale if a data has only one value.\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values);\n  // Fix log scale if it's too small.\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat;\n\n  // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2;\n\n  // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance;\n\n  // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n\n  scaleObject.distance = scaleDistance;\n\n  return scaleObject;\n}\n\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nfunction _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\nfunction getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n  if (!scaleObject) {\n    return null;\n  }\n\n  // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type;\n  // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n  return _adjustContinuousScale(props, scaleObject);\n}\n\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\nfunction getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\nfunction getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n  return null;\n}\n\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\nfunction getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n  return null;\n}\n\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\nfunction getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      (0, _reactUtils.warning)('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n  return null;\n}\n\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\nfunction getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', _propTypes2.default.any), _defineProperty(_ref2, attr + 'Domain', _propTypes2.default.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), _propTypes2.default.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', _propTypes2.default.func), _defineProperty(_ref2, attr + 'Range', _propTypes2.default.array), _defineProperty(_ref2, attr + 'Type', _propTypes2.default.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', _propTypes2.default.number), _defineProperty(_ref2, attr + 'BaseValue', _propTypes2.default.any), _ref2;\n}\n\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nfunction extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0;\n      // Ex: _data\n      var isUnderscoreSet = key.indexOf('_' + a) === 0;\n      // EX: getX\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n    if (!attr) {\n      return;\n    }\n    result[key] = props[key];\n  });\n  return result;\n}\n\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nfunction getMissingScaleProps(props, data, attributes) {\n  var result = {};\n  // Make sure that the domain is set pad it if specified\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\nfunction literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n\n  return scale;\n}\n\nfunction getFontColorFromBackground(background) {\n  if (background) {\n    return (0, _d3Color.hsl)(background).l > 0.57 ? '#222' : '#fff';\n  }\n  return null;\n}\n\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nfunction getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n    return prev;\n  }, {});\n\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n      return prev;\n    }, {});\n  });\n}\n\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\nfunction getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n    if (propIsNotOptional) {\n      return acc;\n    }\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\n\nexports.default = {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};"]},"metadata":{},"sourceType":"script"}