{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ANIMATED_SERIES_PROPS = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}; // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nexports.isSeriesChild = isSeriesChild;\nexports.getSeriesChildren = getSeriesChildren;\nexports.getStackedData = getStackedData;\nexports.getSeriesPropsFromChildren = getSeriesPropsFromChildren;\nexports.getRadialDomain = getRadialDomain;\nexports.getStackParams = getStackParams;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _abstractSeries = require('../plot/series/abstract-series');\n\nvar _abstractSeries2 = _interopRequireDefault(_abstractSeries);\n\nvar _theme = require('../theme');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\n\n\nfunction isSeriesChild(child) {\n  var prototype = child.type.prototype;\n  return prototype instanceof _abstractSeries2.default;\n}\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\n\n\nfunction getSeriesChildren(children) {\n  return _react2.default.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\n\n\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\n\n\nfunction getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  }); // It stores the last segment position added to each bar, separated by cluster.\n\n  var latestAttrPositions = {};\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n\n    var seriesType = series.type.displayName;\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]]; // It is the first segment of a bar.\n\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n        return _extends({}, d);\n      } // Calculate the position of the next segment in a bar.\n\n\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n      return nextD;\n    }));\n    return accumulator;\n  }, []);\n}\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\n\n\nfunction getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = _theme.DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = _theme.DISCRETE_COLOR_RANGE[seriesIndex % _theme.DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster; // Using Array.from() so we can use .indexOf\n\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n\n    result.push(props);\n  });\n  return result;\n}\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\n\n\nfunction getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\n\nvar ANIMATED_SERIES_PROPS = exports.ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\n\nfunction getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex; // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n\n  return {\n    sameTypeTotal: sameTypeTotal,\n    sameTypeIndex: sameTypeIndex\n  };\n}","map":{"version":3,"sources":["D:/reactjs/test/node_modules/react-vis/dist/utils/series-utils.js"],"names":["Object","defineProperty","exports","value","ANIMATED_SERIES_PROPS","undefined","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","isSeriesChild","getSeriesChildren","getStackedData","getSeriesPropsFromChildren","getRadialDomain","getStackParams","_react","require","_react2","_interopRequireDefault","_abstractSeries","_abstractSeries2","_theme","obj","__esModule","default","_defineProperty","enumerable","configurable","writable","child","type","children","Children","toArray","filter","collectSeriesTypesInfo","result","forEach","displayName","cluster","props","sameTypeTotal","sameTypeIndex","clusters","Set","add","seriesHasAngleRadius","data","some","row","radius","angle","prepareData","map","x","Math","cos","y","sin","attr","areSomeSeriesStacked","series","stack","latestAttrPositions","reduce","accumulator","seriesIndex","push","seriesType","_series$props","_series$props$cluster","preppedData","attr0","baseAttr","d","dIndex","_extends2","_latestAttrPositions$2","prevD","_latestAttrPositions$","nextD","seriesTypesInfo","_opacityValue","DEFAULT_OPACITY","seriesTypeInfo","_colorValue","DISCRETE_COLOR_RANGE","Array","from","indexOf","res","max","_stackBy","valuePosAttr","_props$sameTypeTotal","_props$sameTypeIndex"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ANIMATED_SERIES_PROPS = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexports.isSeriesChild = isSeriesChild;\nexports.getSeriesChildren = getSeriesChildren;\nexports.getStackedData = getStackedData;\nexports.getSeriesPropsFromChildren = getSeriesPropsFromChildren;\nexports.getRadialDomain = getRadialDomain;\nexports.getStackParams = getStackParams;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _abstractSeries = require('../plot/series/abstract-series');\n\nvar _abstractSeries2 = _interopRequireDefault(_abstractSeries);\n\nvar _theme = require('../theme');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\nfunction isSeriesChild(child) {\n  var prototype = child.type.prototype;\n\n  return prototype instanceof _abstractSeries2.default;\n}\n\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\nfunction getSeriesChildren(children) {\n  return _react2.default.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\nfunction getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  });\n  // It stores the last segment position added to each bar, separated by cluster.\n  var latestAttrPositions = {};\n\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n    var seriesType = series.type.displayName;\n\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]];\n      // It is the first segment of a bar.\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n\n        return _extends({}, d);\n      }\n\n      // Calculate the position of the next segment in a bar.\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n\n      return nextD;\n    }));\n\n    return accumulator;\n  }, []);\n}\n\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\nfunction getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = _theme.DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = _theme.DISCRETE_COLOR_RANGE[seriesIndex % _theme.DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster;\n        // Using Array.from() so we can use .indexOf\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n    result.push(props);\n  });\n  return result;\n}\n\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\nfunction getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\n\nvar ANIMATED_SERIES_PROPS = exports.ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\n\nfunction getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex;\n\n  // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n  return { sameTypeTotal: sameTypeTotal, sameTypeIndex: sameTypeIndex };\n}"]},"metadata":{},"sourceType":"script"}