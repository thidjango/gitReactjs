{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DIRECTION = exports.ORIENTATION = undefined;\nexports.getTicksTotalFromSize = getTicksTotalFromSize;\nexports.getTickValues = getTickValues;\nexports.generateFit = generateFit;\nexports.generatePoints = generatePoints;\nexports.getAxisAngle = getAxisAngle;\n\nvar _d3Array = require('d3-array');\n\nvar _d3Scale = require('d3-scale'); // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nvar ORIENTATION = exports.ORIENTATION = {\n  TOP: 'top',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\nvar DIRECTION = exports.DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n/**\n * Get total amount of ticks from a given size in pixels.\n * @param {number} size Size of the axis in pixels.\n * @returns {number} Total amount of ticks.\n */\n\nfunction getTicksTotalFromSize(size) {\n  if (size < 700) {\n    if (size > 300) {\n      return 10;\n    }\n\n    return 5;\n  }\n\n  return 20;\n}\n/**\n * Get the tick values from a given d3 scale.\n * @param {d3.scale} scale Scale function.\n * @param {number} tickTotal Total number of ticks\n * @param {Array} tickValues Array of tick values if they exist.\n * @returns {Array} Array of tick values.\n */\n\n\nfunction getTickValues(scale, tickTotal, tickValues) {\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\n}\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Object describing each the line in coordinates\n */\n\n\nfunction generateFit(axisStart, axisEnd) {\n  // address the special case when the slope is infinite\n  if (axisStart.x === axisEnd.x) {\n    return {\n      left: axisStart.y,\n      right: axisEnd.y,\n      slope: 0,\n      offset: axisStart.x\n    };\n  }\n\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\n  return {\n    left: axisStart.x,\n    right: axisEnd.x,\n    // generate the linear projection of the axis direction\n    slope: slope,\n    offset: axisStart.y - slope * axisStart.x\n  };\n}\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param props\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Number} numberOfTicks The number of ticks on the axis\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\n * @returns {Number} Object describing the slope and the specific coordinates of the points\n */\n\n\nfunction generatePoints(_ref) {\n  var axisStart = _ref.axisStart,\n      axisEnd = _ref.axisEnd,\n      numberOfTicks = _ref.numberOfTicks,\n      axisDomain = _ref.axisDomain;\n\n  var _generateFit = generateFit(axisStart, axisEnd),\n      left = _generateFit.left,\n      right = _generateFit.right,\n      slope = _generateFit.slope,\n      offset = _generateFit.offset; // construct a linear band of points, then map them\n\n\n  var pointSlope = (right - left) / numberOfTicks;\n  var axisScale = (0, _d3Scale.scaleLinear)().domain([left, right]).range(axisDomain);\n  var slopeVertical = axisStart.x === axisEnd.x;\n  return {\n    slope: slopeVertical ? Infinity : slope,\n    points: (0, _d3Array.range)(left, right + pointSlope, pointSlope).map(function (val) {\n      if (slopeVertical) {\n        return {\n          y: val,\n          x: slope * val + offset,\n          text: axisScale(val)\n        };\n      }\n\n      return {\n        x: val,\n        y: slope * val + offset,\n        text: axisScale(val)\n      };\n    }).slice(0, numberOfTicks + 1)\n  };\n}\n/**\n * Compute the angle (in radians) of a decorative axis\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Angle in radials\n */\n\n\nfunction getAxisAngle(axisStart, axisEnd) {\n  if (axisStart.x === axisEnd.x) {\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\n  }\n\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\n}\n\nexports.default = {\n  DIRECTION: DIRECTION,\n  ORIENTATION: ORIENTATION,\n  getTicksTotalFromSize: getTicksTotalFromSize,\n  getTickValues: getTickValues\n};","map":{"version":3,"sources":["D:/reactjs/test/node_modules/react-vis/dist/utils/axis-utils.js"],"names":["Object","defineProperty","exports","value","DIRECTION","ORIENTATION","undefined","getTicksTotalFromSize","getTickValues","generateFit","generatePoints","getAxisAngle","_d3Array","require","_d3Scale","TOP","LEFT","RIGHT","BOTTOM","VERTICAL","HORIZONTAL","size","scale","tickTotal","tickValues","ticks","domain","axisStart","axisEnd","x","left","y","right","slope","offset","_ref","numberOfTicks","axisDomain","_generateFit","pointSlope","axisScale","scaleLinear","range","slopeVertical","Infinity","points","map","val","text","slice","Math","PI","atan","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DIRECTION = exports.ORIENTATION = undefined;\nexports.getTicksTotalFromSize = getTicksTotalFromSize;\nexports.getTickValues = getTickValues;\nexports.generateFit = generateFit;\nexports.generatePoints = generatePoints;\nexports.getAxisAngle = getAxisAngle;\n\nvar _d3Array = require('d3-array');\n\nvar _d3Scale = require('d3-scale');\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nvar ORIENTATION = exports.ORIENTATION = {\n  TOP: 'top',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n\nvar DIRECTION = exports.DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n\n/**\n * Get total amount of ticks from a given size in pixels.\n * @param {number} size Size of the axis in pixels.\n * @returns {number} Total amount of ticks.\n */\nfunction getTicksTotalFromSize(size) {\n  if (size < 700) {\n    if (size > 300) {\n      return 10;\n    }\n    return 5;\n  }\n  return 20;\n}\n\n/**\n * Get the tick values from a given d3 scale.\n * @param {d3.scale} scale Scale function.\n * @param {number} tickTotal Total number of ticks\n * @param {Array} tickValues Array of tick values if they exist.\n * @returns {Array} Array of tick values.\n */\nfunction getTickValues(scale, tickTotal, tickValues) {\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\n}\n\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Object describing each the line in coordinates\n */\nfunction generateFit(axisStart, axisEnd) {\n  // address the special case when the slope is infinite\n  if (axisStart.x === axisEnd.x) {\n    return {\n      left: axisStart.y,\n      right: axisEnd.y,\n      slope: 0,\n      offset: axisStart.x\n    };\n  }\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\n  return {\n    left: axisStart.x,\n    right: axisEnd.x,\n    // generate the linear projection of the axis direction\n    slope: slope,\n    offset: axisStart.y - slope * axisStart.x\n  };\n}\n\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param props\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Number} numberOfTicks The number of ticks on the axis\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\n * @returns {Number} Object describing the slope and the specific coordinates of the points\n */\nfunction generatePoints(_ref) {\n  var axisStart = _ref.axisStart,\n      axisEnd = _ref.axisEnd,\n      numberOfTicks = _ref.numberOfTicks,\n      axisDomain = _ref.axisDomain;\n\n  var _generateFit = generateFit(axisStart, axisEnd),\n      left = _generateFit.left,\n      right = _generateFit.right,\n      slope = _generateFit.slope,\n      offset = _generateFit.offset;\n  // construct a linear band of points, then map them\n\n\n  var pointSlope = (right - left) / numberOfTicks;\n  var axisScale = (0, _d3Scale.scaleLinear)().domain([left, right]).range(axisDomain);\n\n  var slopeVertical = axisStart.x === axisEnd.x;\n  return {\n    slope: slopeVertical ? Infinity : slope,\n    points: (0, _d3Array.range)(left, right + pointSlope, pointSlope).map(function (val) {\n      if (slopeVertical) {\n        return { y: val, x: slope * val + offset, text: axisScale(val) };\n      }\n      return { x: val, y: slope * val + offset, text: axisScale(val) };\n    }).slice(0, numberOfTicks + 1)\n  };\n}\n\n/**\n * Compute the angle (in radians) of a decorative axis\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Angle in radials\n */\nfunction getAxisAngle(axisStart, axisEnd) {\n  if (axisStart.x === axisEnd.x) {\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\n  }\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\n}\n\nexports.default = {\n  DIRECTION: DIRECTION,\n  ORIENTATION: ORIENTATION,\n  getTicksTotalFromSize: getTicksTotalFromSize,\n  getTickValues: getTickValues\n};"]},"metadata":{},"sourceType":"script"}